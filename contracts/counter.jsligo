type storage = int;
type parameter =
| ["Increment", int]
| ["Decrement", int]
| ["Reset"];
type return_ = [list <operation>, storage];
/* Two entrypoints */
let add = ([store, delta] : [storage, int]) : storage => store + delta;
let sub = ([store, delta] : [storage, int]) : storage => store - delta;
/* Main access point that dispatches to the entrypoints according to
   the smart contract parameter. */
let main = ([action, store] : [parameter, storage]) : return_ => {
 return [
   (list([]) as list <operation>),    // No operations
   (match (action, {
    Increment: (n: int) => add ([store, n]),
    Decrement: (n: int) => sub ([store, n]),
    Reset:     ()  => 0}))
  ]
};
/* Tests for main access point */
let _test_initial_storage = () : bool => {
  let initial_storage = 42 as int;
  let [taddr, _, _] = Test.originate(main, initial_storage, 0 as tez);
  return (Test.get_storage(taddr) == initial_storage);
};
let test_initial_storage = _test_initial_storage();
let _test_increment = () : bool => {
  let initial_storage = 42 as int;
  let [taddr, _, _] = Test.originate(main, initial_storage, 0 as tez);
  let contr = Test.to_contract(taddr);
  let r = Test.transfer_to_contract_exn(contr, (Increment (1)), 1 as mutez);
  return (Test.get_storage(taddr) == initial_storage + 1);
}
let test_increment = _test_increment();